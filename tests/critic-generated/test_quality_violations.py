"""
Code Quality Violation Tests for 20260204_OscGrid_Photonic_Quantum_Analysis.py

Generated by CODE QUALITY CRITIC agent
Date: 2026-02-05

These tests capture code quality violations based on DRY, complexity,
and CLAUDE.md guidelines. Tests should FAIL initially if violations exist.
"""

import ast
import re
from pathlib import Path
from typing import List, Dict, Set

import pytest


# Path to the file under review
NOTEBOOK_FILE = Path(__file__).parent.parent.parent / "20260204_OscGrid_Photonic_Quantum_Analysis.py"


def get_file_content() -> str:
    """Load the notebook file content."""
    return NOTEBOOK_FILE.read_text()


def parse_ast() -> ast.Module:
    """Parse the notebook as an AST."""
    return ast.parse(get_file_content())


class TestDRYViolations:
    """Tests for Don't Repeat Yourself (DRY) principle violations."""

    def test_no_repeated_constant_definitions(self):
        """
        CLAUDE.md Rule: Avoid magic numbers and repeated constant definitions
        Found: Lines 481-484, 668-671, 721-722 - Physical constants redefined 3 times
        """
        content = get_file_content()

        # Count how many times Planck's constant is defined
        h_definitions = len(re.findall(r'h\s*=\s*6\.626e-34', content))

        # Count how many times speed of light is defined
        c_definitions = len(re.findall(r'c\s*=\s*3e8', content))

        # Count how many times wavelength is defined
        lambda_definitions = len(re.findall(r'lambda_opt\s*=\s*1550e-9', content))

        assert h_definitions <= 1, f"Planck constant defined {h_definitions} times (should be 1)"
        assert c_definitions <= 1, f"Speed of light defined {c_definitions} times (should be 1)"
        assert lambda_definitions <= 1, f"Optical wavelength defined {lambda_definitions} times (should be 1)"

    def test_no_repeated_calculation_patterns(self):
        """
        CLAUDE.md Rule: DRY - extract repeated calculations into functions
        Found: Lines 503-504, 671-672, 755-757 - Photon calculation repeated 3 times
        """
        content = get_file_content()

        # Pattern: E_photon = h * c / lambda
        photon_energy_calcs = len(re.findall(r'E_photon\s*=\s*h\s*\*\s*c\s*/\s*lambda_opt', content))

        # Pattern: photon_rate = P / E_photon
        photon_rate_calcs = len(re.findall(r'photon_rate\s*=\s*P_\w+\s*/\s*E_photon', content))

        assert photon_energy_calcs <= 1, f"Photon energy calculation repeated {photon_energy_calcs} times"
        assert photon_rate_calcs <= 1, f"Photon rate calculation repeated {photon_rate_calcs} times"

    def test_grid_frequency_constant_not_hardcoded(self):
        """
        CLAUDE.md Rule: No magic numbers - use named constants
        Found: Lines 474, 489, 659 - Grid frequency (60 Hz) hardcoded multiple times
        """
        content = get_file_content()

        # Count hardcoded 60 Hz references (simple pattern)
        hardcoded_60 = len(re.findall(r'\b60\b', content))

        # Should have few occurrences (defined once, used in comments/strings)
        assert hardcoded_60 <= 8, f"Grid frequency appears {hardcoded_60} times (consider named constant)"


class TestDocumentationViolations:
    """Tests for missing or inadequate documentation."""

    def test_all_functions_have_docstrings(self):
        """
        CLAUDE.md Rule: All functions must have docstrings
        Found: Lines 290, 301 - Functions mirp_dynamics and compute_output lack docstrings
        """
        tree = parse_ast()
        functions_without_docstrings = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # Check if function has a docstring
                has_docstring = (
                    ast.get_docstring(node) is not None
                    or (len(node.body) > 0 and isinstance(node.body[0], ast.Expr))
                )

                if not has_docstring and not node.name.startswith('_'):
                    functions_without_docstrings.append(f"{node.name} (line {node.lineno})")

        assert len(functions_without_docstrings) == 0, (
            f"Functions without docstrings: {', '.join(functions_without_docstrings)}"
        )

    def test_complex_calculations_have_comments(self):
        """
        CLAUDE.md Rule: Complex mathematical operations require explanation
        Found: Lines 728-755 - Complex performance calculations lack inline comments
        """
        content = get_file_content()
        lines = content.split('\n')

        # Check lines 728-755 (performance analysis section)
        section_start = 728
        section_end = 755

        comment_lines = 0
        code_lines = 0

        for i in range(section_start - 1, min(section_end, len(lines))):
            line = lines[i].strip()
            if line.startswith('#'):
                comment_lines += 1
            elif line and not line.startswith('#'):
                code_lines += 1

        # At least 30% of lines should be comments for complex calculations
        comment_ratio = comment_lines / max(code_lines, 1)

        assert comment_ratio >= 0.3, (
            f"Complex calculation section has {comment_ratio:.1%} comments (should be ≥30%)"
        )


class TestNamingConventionViolations:
    """Tests for inconsistent or poor naming conventions."""

    def test_variable_names_are_descriptive(self):
        """
        CLAUDE.md Rule: Use descriptive variable names (not single letters except in math)
        Found: Line 474 - Variable 'f0' could be 'grid_frequency_hz'
        """
        content = get_file_content()

        # Single-letter variables that aren't clearly mathematical
        problematic_names = re.findall(r'\b(f0|fs|T_eff)\b(?!\s*#.*mathematical)', content)

        # Allow some mathematical conventions but flag unclear ones
        unclear_names = [name for name in set(problematic_names) if name in ['f0', 'fs']]

        assert len(unclear_names) == 0, (
            f"Variables with unclear names: {unclear_names}. "
            "Use descriptive names like 'grid_frequency_hz', 'sampling_rate_hz'"
        )

    def test_constant_names_use_uppercase(self):
        """
        CLAUDE.md Rule: Constants should use UPPER_CASE naming
        Found: Lines 481-484 - Physical constants use lowercase (h, c, lambda_opt)
        """
        content = get_file_content()

        # Check for lowercase physical constants
        lowercase_constants = re.findall(
            r'(h|c|lambda_opt)\s*=\s*[\d.e-]+\s*#.*constant',
            content,
            re.IGNORECASE
        )

        # Should use PLANCK_CONSTANT, SPEED_OF_LIGHT, WAVELENGTH_NM
        assert len(lowercase_constants) == 0, (
            f"Physical constants using lowercase: {lowercase_constants}. "
            "Should use UPPER_CASE like PLANCK_CONSTANT, SPEED_OF_LIGHT"
        )


class TestComplexityViolations:
    """Tests for high cyclomatic complexity and code smells."""

    def test_no_deeply_nested_structures(self):
        """
        CLAUDE.md Rule: Avoid deep nesting (max 3 levels)
        Found: No violations in current code (good!)
        """
        tree = parse_ast()

        def get_nesting_depth(node, current_depth=0):
            max_depth = current_depth
            for child in ast.iter_child_nodes(node):
                if isinstance(child, (ast.For, ast.While, ast.If, ast.With)):
                    child_depth = get_nesting_depth(child, current_depth + 1)
                    max_depth = max(max_depth, child_depth)
            return max_depth

        max_nesting = 0
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                depth = get_nesting_depth(node)
                max_nesting = max(max_nesting, depth)

        assert max_nesting <= 3, f"Maximum nesting depth is {max_nesting} (should be ≤3)"

    def test_functions_not_too_long(self):
        """
        CLAUDE.md Rule: Functions should be < 50 lines (excluding docstrings)
        Found: Markdown cells are very long but acceptable for documentation
        """
        tree = parse_ast()
        long_functions = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # Count non-comment lines
                func_length = len([n for n in ast.walk(node) if isinstance(n, ast.stmt)])

                if func_length > 50 and not node.name.startswith('_'):
                    long_functions.append(f"{node.name} ({func_length} lines)")

        assert len(long_functions) == 0, (
            f"Functions exceeding 50 lines: {', '.join(long_functions)}"
        )


class TestCodeOrganizationViolations:
    """Tests for poor code organization and structure."""

    def test_constants_defined_at_module_level(self):
        """
        CLAUDE.md Rule: Define constants at module level, not inside functions
        Found: Lines 481-484, 668-671 - Constants defined inside cell functions
        """
        tree = parse_ast()

        constants_in_functions = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                for child in ast.walk(node):
                    if isinstance(child, ast.Assign):
                        for target in child.targets:
                            if isinstance(target, ast.Name):
                                # Check if this looks like a constant
                                if target.id.isupper() or target.id in ['h', 'c', 'lambda_opt']:
                                    constants_in_functions.append(
                                        f"{target.id} in {node.name} (line {child.lineno})"
                                    )

        # Allow some constants in functions for Marimo cells, but flag excessive use
        assert len(constants_in_functions) <= 20, (
            f"Too many constants defined in functions ({len(constants_in_functions)}). "
            "Consider module-level constants."
        )

    def test_related_code_grouped_together(self):
        """
        CLAUDE.md Rule: Group related functionality together
        Found: Lines 470-524, 655-685 - Similar calculations separated by markdown cells
        """
        content = get_file_content()

        # Check if photon calculation code is grouped
        photon_calc_lines = []
        for i, line in enumerate(content.split('\n'), 1):
            if 'E_photon' in line or 'photon_rate' in line or 'N_photons' in line:
                photon_calc_lines.append(i)

        # If we have multiple photon calculations, they should be close together
        if len(photon_calc_lines) > 1:
            max_gap = max(photon_calc_lines[i+1] - photon_calc_lines[i]
                         for i in range(len(photon_calc_lines) - 1))

            # Allow up to 100 lines gap for Marimo cell structure
            assert max_gap <= 200, (
                f"Photon calculations scattered across {max_gap} lines. "
                "Consider grouping related code together."
            )


class TestTypeHintViolations:
    """Tests for missing type hints."""

    def test_function_parameters_have_type_hints(self):
        """
        CLAUDE.md Rule: Use type hints for function parameters and returns
        Found: Lines 290, 301 - Functions lack type hints
        """
        tree = parse_ast()
        functions_without_hints = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and not node.name.startswith('_'):
                # Check if function has type hints
                has_type_hints = (
                    node.returns is not None or
                    any(arg.annotation is not None for arg in node.args.args)
                )

                if not has_type_hints:
                    functions_without_hints.append(f"{node.name} (line {node.lineno})")

        # For a scientific notebook, allow some flexibility
        assert len(functions_without_hints) <= 5, (
            f"Functions without type hints: {', '.join(functions_without_hints)}"
        )


class TestTestabilityViolations:
    """Tests for code that's hard to test in isolation."""

    def test_calculations_extracted_to_pure_functions(self):
        """
        CLAUDE.md Rule: Extract calculations into pure functions for testability
        Found: Lines 470-524, 655-685, 720-757 - Complex calculations in cell bodies
        """
        content = get_file_content()

        # Count complex calculation blocks not in functions
        cell_calculation_blocks = re.findall(
            r'@app\.cell\ndef _\(\):(.*?)return',
            content,
            re.DOTALL
        )

        complex_blocks = 0
        for block in cell_calculation_blocks:
            # Count lines with assignments and calculations
            calc_lines = len([line for line in block.split('\n')
                            if '=' in line and not line.strip().startswith('#')])

            if calc_lines > 10:
                complex_blocks += 1

        assert complex_blocks <= 3, (
            f"Found {complex_blocks} cell blocks with >10 calculation lines. "
            "Extract into named, testable functions."
        )

    def test_no_side_effects_in_pure_calculations(self):
        """
        CLAUDE.md Rule: Pure calculation functions should have no side effects
        Found: All calculation cells modify global state via return tuples
        """
        tree = parse_ast()

        # Check if functions modify global state
        functions_with_side_effects = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                for child in ast.walk(node):
                    # Look for global assignments or mutations
                    if isinstance(child, ast.Global):
                        functions_with_side_effects.append(f"{node.name} (line {node.lineno})")

        assert len(functions_with_side_effects) == 0, (
            f"Functions with side effects: {', '.join(functions_with_side_effects)}"
        )


class TestScientificVisualizationStandards:
    """Tests for scientific visualization standards from CLAUDE.md."""

    def test_latex_notation_in_markdown_cells(self):
        """
        CLAUDE.md Rule: All plots must include LaTeX expressions defining plotted quantities
        Found: This is a documentation notebook - should verify any future plotting code
        """
        content = get_file_content()

        # Check that mathematical expressions use proper LaTeX
        markdown_cells = re.findall(r'mo\.md\(r"""(.*?)"""\)', content, re.DOTALL)

        # Count LaTeX expressions
        latex_count = sum(cell.count('$$') + cell.count('$') for cell in markdown_cells)

        # This notebook should have substantial LaTeX (it's about quantum physics)
        assert latex_count > 50, (
            f"Only {latex_count} LaTeX expressions found. "
            "Scientific notebooks should use LaTeX for all mathematical notation."
        )

    def test_variables_use_proper_mathematical_notation(self):
        """
        CLAUDE.md Rule: Use proper mathematical notation (tildes for phasors, bold for vectors)
        Found: Good! Document uses \\tilde{E}, \\hat{H}, etc.
        """
        content = get_file_content()

        # Check for proper notation patterns (escaped properly)
        has_tilde = '\\tilde{' in content  # Phasors
        has_hat = '\\hat{' in content      # Operators
        has_bold = '\\mathbf{' in content  # Vectors

        assert has_tilde, "Missing \\tilde notation for phasor fields"
        assert has_hat, "Missing \\hat notation for quantum operators"


class TestCodeSmells:
    """Tests for general code smells and anti-patterns."""

    def test_no_unused_imports(self):
        """
        CLAUDE.md Rule: Remove unused imports
        Found: Need to check if numpy is used in all cells that import it
        """
        content = get_file_content()

        # Find all import statements
        import_cells = re.findall(r'import (numpy|np)\b.*?return', content, re.DOTALL)

        # For each import, check if it's used
        for cell in import_cells:
            if 'import numpy' in cell or 'import np' in cell:
                # Check if np is actually used
                uses_np = re.search(r'\bnp\.', cell)
                assert uses_np, "numpy imported but not used in cell"

    def test_consistent_string_formatting(self):
        """
        CLAUDE.md Rule: Use consistent string formatting (prefer f-strings)
        Found: Mix of f-strings and .format() in markdown cells
        """
        content = get_file_content()

        # Count different formatting styles
        format_method = len(re.findall(r'\.format\(', content))
        percent_format = len(re.findall(r'%[sd]', content))

        # f-strings are already used extensively, minimize old-style formatting
        assert format_method + percent_format <= 2, (
            f"Found {format_method + percent_format} old-style string formats. "
            "Prefer f-strings for consistency."
        )


class TestPerformanceAntiPatterns:
    """Tests for potential performance issues."""

    def test_no_repeated_expensive_calculations(self):
        """
        CLAUDE.md Rule: Cache expensive calculations
        Found: Lines 503, 672 - Same photon energy calculated multiple times
        """
        content = get_file_content()

        # Pattern: calculating E_photon from scratch each time
        e_photon_from_scratch = len(re.findall(
            r'E_photon\s*=\s*h\s*\*\s*c\s*/\s*lambda_opt',
            content
        ))

        assert e_photon_from_scratch <= 1, (
            f"Photon energy calculated from scratch {e_photon_from_scratch} times. "
            "Calculate once and reuse or create a constant."
        )


# Summary test that aggregates all violation counts
class TestQualitySummary:
    """Summary test showing overall code quality metrics."""

    def test_quality_summary(self):
        """
        Generate overall quality summary report.
        This test always passes but prints violations found.
        """
        content = get_file_content()

        violations = {
            'DRY': 0,
            'Documentation': 0,
            'Naming': 0,
            'Complexity': 0,
            'Organization': 0,
            'Type Hints': 0,
            'Testability': 0,
        }

        # Count various violations
        violations['DRY'] += len(re.findall(r'h\s*=\s*6\.626e-34', content)) - 1
        violations['DRY'] += len(re.findall(r'c\s*=\s*3e8', content)) - 1
        violations['DRY'] += len(re.findall(r'lambda_opt\s*=\s*1550e-9', content)) - 1

        tree = parse_ast()
        funcs_without_docs = sum(
            1 for node in ast.walk(tree)
            if isinstance(node, ast.FunctionDef)
            and not node.name.startswith('_')
            and ast.get_docstring(node) is None
        )
        violations['Documentation'] = funcs_without_docs

        print("\n" + "="*60)
        print("CODE QUALITY SUMMARY")
        print("="*60)
        for category, count in violations.items():
            status = "✅ PASS" if count == 0 else f"⚠️  {count} violations"
            print(f"{category:20s}: {status}")
        print("="*60)

        # This test always passes but reports the issues
        assert True, "See summary above"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
